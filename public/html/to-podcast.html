
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音频分割工具 & 播客生成</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <style>
        /* Keep the same custom styles */
        .region-handle { width: 6px; height: 100%; position: absolute; top: 0; cursor: col-resize; background-color: rgba(255, 255, 255, 0.5); }
        .region-handle-left { left: 0; }
        .region-handle-right { right: 0; }
        .wavesurfer-region { z-index: 3 !important; }
        #waveform .wavesurfer-region { border-left: 2px solid rgba(255, 0, 0, 0.8); border-right: 2px solid rgba(255, 0, 0, 0.8); }
        .segment-row:hover { background-color: rgba(243, 244, 246, 0.8); }
        .sensitivity-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #3B82F6; border-radius: 50%; cursor: pointer; }
        .sensitivity-slider::-moz-range-thumb { width: 18px; height: 18px; background: #3B82F6; border-radius: 50%; cursor: pointer; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 2s linear infinite; }
        .sticky-controls { position: sticky; top: 0; z-index: 50; background-color: rgba(255, 255, 255, 0.95); padding: 10px; border-radius: 0 0 8px 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); transition: all 0.3s ease; }
        .sticky-controls div { margin-bottom: 0; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        [v-cloak] { display: none; }
        .subtitle-item { cursor: pointer; padding: 4px 8px; margin-bottom: 2px; border-radius: 4px; transition: background-color 0.2s; }
        .subtitle-item:hover { background-color: #e0e7ff; }
        .subtitle-item.active { background-color: #c7d2fe; font-weight: bold;}
    </style>
</head>
<body class="bg-gray-100 min-h-screen font-sans">

    <div id="app" v-cloak>
        <div id="loading-overlay" v-if="isLoading">
            <div class="text-center">
                <div class="loader mx-auto mb-4"></div>
                <p class="text-white text-lg" id="loading-message">{{ loadingMessage }}</p>
            </div>
        </div>

        <div class="container mx-auto px-4 py-8">
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">音频分割工具 & 播客生成</h1>

            <!-- API Settings -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold flex justify-between items-center">
                    AI 功能设置（字幕/摘要生成）
                    <button @click="toggleApiSettings" class="text-sm text-blue-500 hover:text-blue-700">
                        {{ apiSettingsVisible ? '隐藏' : '显示' }}
                    </button>
                </h2>

                <div v-show="apiSettingsVisible">
                    <div class="my-4 grid md:grid-cols-2 gap-4">
                        <div>
                            <label for="apiUrl" class="block text-sm font-medium text-gray-700">API URL</label>
                            <input type="text" id="apiUrl" v-model="apiConfig.url" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="https://api.openai.com/v1/chat/completions">
                        </div>
                        <div>
                            <label for="apiKey" class="block text-sm font-medium text-gray-700">API Key:</label>
                            <input type="password" id="apiKey" v-model="apiConfig.key" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="Bearer your_api_key or just your_api_key">
                        </div>
                        <div>
                            <label for="sttModel" class="block text-sm font-medium text-gray-700">字幕模型</label>

                            <select v-model="apiConfig.sttModel" id="sttModel" class="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <option value="gemini-2.0-flash-exp">gemini-2.0-flash-exp</option>
                                <option value="gemini-2.5-flash-preview-04-17">gemini-2.5-flash-preview-04-17</option>
                                <option value="gemini-2.5-flash-preview-05-20">gemini-2.5-flash-preview-05-20</option>
                            </select>
                        </div>
                        <div>
                            <label for="summaryModel" class="block text-sm font-medium text-gray-700">摘要模型</label>
                            <input type="text" id="summaryModel" v-model="apiConfig.summaryModel" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="gemini-2.5-pro">
                        </div>
                    </div>
    
                    <button @click="saveApiConfig" class="py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-lg transition duration-200">保存设置</button>    
                </div>
            </div>

            <!-- 1. Upload -->
            <div class="bg-white rounded-lg shadow-md p-4 mb-6">
                <h2 class="text-lg font-semibold mb-3">1. 上传音频</h2>
                <div class="flex flex-col items-center gap-3">
                    <label class="w-full cursor-pointer">
                        <div 
                            class="w-full p-5 border-2 border-dashed border-gray-300 rounded-lg text-center hover:border-blue-400 hover:bg-blue-50 transition-colors"
                            @dragover.prevent="handleDragOver"
                            @dragleave.prevent="handleDragLeave"
                            @drop.prevent="handleDrop"
                            :class="{ 'bg-blue-100 border-blue-400': isDraggingOver }"
                        >
                            <p class="mb-2">支持mp3、wav、m3u8等格式</p>
                            <p v-show="fileInfo" class="text-sm text-gray-500 mb-3">{{ fileInfo }}</p>
                            <input type="file" id="audio-input" accept="audio/*" class="hidden" @change="handleFileUpload" ref="audioInput"/>
                            <span class="inline-block py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-medium rounded-md transition duration-200">
                                选择文件
                            </span>
                        </div>
                    </label>
                </div>
            </div>

            <!-- 2. Waveform & Subtitles -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">2. 音频波形与字幕</h2>

                <div v-show="isAudioLoaded" class="mb-4">
                    <div class="flex flex-col md:flex-row gap-4 mb-4">
                        <div class="flex-1">
                            <button id="addMarker" @click="addMarkerAtCurrentTime" class="w-full py-2 px-4 bg-green-500 hover:bg-green-600 text-white font-semibold rounded-lg transition duration-200 flex items-center justify-center" :disabled="!isAudioLoaded">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /></svg>
                                在当前位置添加分割点
                            </button>
                        </div>
                        <div class="flex-1">
                            <button id="clearMarkers" @click="clearAllMarkers" class="w-full py-2 px-4 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition duration-200 flex items-center justify-center" :disabled="!isAudioLoaded || !hasRegions">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                清除所有分割点
                            </button>
                        </div>
                    </div>
                </div>
                
                <div id="waveform" ref="waveform" class="w-full h-32 bg-gray-100 mb-2 rounded"></div>
                <div id="timeline" ref="timeline" class="w-full h-6 bg-gray-50 rounded mb-4"></div>

                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center space-x-4">
                        <button id="playPause" @click="playPause" class="py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-lg transition duration-200 flex items-center justify-center" :disabled="!isAudioLoaded">
                            <svg v-if="!isPlaying" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                            <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                            {{ isPlaying ? '暂停' : '播放' }}
                        </button>
                        <button id="zoomIn" @click="zoomIn" class="py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold rounded-lg transition duration-200" :disabled="!isAudioLoaded">放大</button>
                        <button id="zoomOut" @click="zoomOut" class="py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold rounded-lg transition duration-200" :disabled="!isAudioLoaded">缩小</button>
                    </div>
                    <div>
                        <span id="current-time" class="text-gray-600">{{ formattedCurrentTime }}</span> /
                        <span id="total-time" class="text-gray-600">{{ formattedTotalTime }}</span>
                    </div>
                </div>

                <!-- Subtitle Display Area -->
                <div v-if="subtitles.length > 0" class="mt-4 mb-4 p-3 bg-gray-50 rounded-md max-h-60 overflow-y-auto border border-gray-200">
                    <div class="flex items-center justify-between">
                        <h3 class="text-md font-semibold text-gray-700 mb-2">字幕信息 (点击跳转)</h3>
                        <span class="text-sm text-yellow-500 cursor-pointer" @click="splitBySubtitles">自动分割</span>
                    </div>
                    <div v-for="(sub, index) in subtitles" :key="index"
                         class="subtitle-item"
                         :class="{ 'active': sub.start <= currentTime && sub.end > currentTime }"
                         @click="seekToSubtitle(sub.start)">
                        <span class="font-mono text-sm text-blue-600">[{{ formatTime(sub.start) }} - {{ formatTime(sub.end) }}]</span>
                        <span class="ml-2 text-gray-800">{{ sub.text }}</span>
                    </div>
                </div>
                <div v-else-if="isAudioLoaded && !isLoadingSubtitles" class="mt-4 mb-4 p-3 text-center text-gray-500">
                    点击按钮生成字幕后生成摘要
                </div>

                <!-- AI Summary Section -->
                <div v-if="aiSummaryJson" class="mt-4 mb-4">
                    <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                        <h3 class="text-md font-semibold text-gray-700 mb-2">摘要结果</h3>
                        
                        <!-- 美化的结构化展示 -->
                        <div class="mb-4">
                            <div class="mb-3 bg-white p-3 rounded-md border border-gray-200">
                                <h4 class="text-lg font-bold text-purple-700">{{ aiSummaryJson.podcastTitle }}</h4>
                                <h5 class="text-md font-semibold text-gray-800 mt-1">{{ aiSummaryJson.episodeTitle }}</h5>
                                <p class="text-sm text-gray-600 mt-2">{{ aiSummaryJson.overallSummary }}</p>
                            </div>
                            
                            <div class="mt-4">
                                <div class="flex items-center justify-between">
                                    <h3 class="text-md font-semibold text-gray-700 mb-2">章节信息:</h3>
                                    <span class="text-sm text-yellow-500 cursor-pointer" @click="splitByChapters">自动分割</span>
                                </div>
                                <div v-for="(chapter, index) in aiSummaryJson.chapters" :key="index" class="flex mb-2 bg-white p-2 rounded border border-gray-200">
                                    <span class="font-mono text-sm text-blue-600">[{{ formatTime(chapter.start) }} - {{ formatTime(chapter.end) }}]</span>
                                    <span class="ml-2 text-sm font-medium">{{ chapter.title }}</span>
                                </div>
                            </div>
                            
                            <div class="mt-4">
                                <h4 class="font-semibold text-gray-700 mb-2">关键要点:</h4>
                                <ul class="list-disc pl-5">
                                    <li v-for="(point, index) in aiSummaryJson.keyTakeaways" :key="index" class="text-sm mb-1">{{ point }}</li>
                                </ul>
                            </div>
                            
                            <div class="mt-4">
                                <h4 class="font-semibold text-gray-700 mb-2">标签:</h4>
                                <div class="flex flex-wrap gap-2">
                                    <span v-for="(tag, index) in aiSummaryJson.tags" :key="index" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full">#{{ tag }}</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 原始JSON展示（可折叠） -->
                        <div class="mt-3">
                            <button @click="showJsonView = !showJsonView" class="text-sm text-blue-600 hover:text-blue-800 mb-2 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path v-if="showJsonView" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                    <path v-else stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                </svg>
                                {{ showJsonView ? '隐藏JSON格式' : '显示JSON格式' }}
                            </button>
                            <pre v-if="showJsonView" class="text-sm whitespace-pre-wrap break-all overflow-x-auto max-h-96 bg-gray-100 p-2 rounded">{{ aiSummaryJson }}</pre>
                            <button @click="copySummaryToClipboard" class="mt-3 py-1 px-3 bg-blue-500 hover:bg-blue-600 text-white text-xs font-medium rounded-md transition duration-200">复制 JSON</button>
                        </div>
                    </div>
                </div>

                <div v-show="isAudioLoaded" class="grid grid-cols-2 gap-4">
                    <button @click="generateSubtitles" class="py-2 px-4 bg-purple-500 hover:bg-purple-600 text-white font-semibold rounded-lg transition duration-200 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" :disabled="!isAudioLoaded || isLoadingSubtitles || !apiConfig.url || !apiConfig.key">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd" /></svg>
                        {{ isLoadingSubtitles ? '字幕生成中...' : '生成字幕' }}
                    </button>

                    <button @click="generateAiSummary" class="py-2 px-4 bg-purple-500 hover:bg-purple-600 text-white font-semibold rounded-lg transition duration-200 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" :disabled="subtitles.length === 0 || isLoadingSummary || !apiConfig.url || !apiConfig.key">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" /></svg>
                        {{ isLoadingSummary ? '摘要生成中...' : '摘要信息' }}
                    </button>
                </div>
                 <p v-if="!apiConfig.url || !apiConfig.key" class="text-xs text-red-500 text-center mt-1">请先在上方设置 API URL 和 Key 以启用此功能。</p>
            </div>


            <!-- 3. Split Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6" v-show="isAudioLoaded">
                <!-- ... existing split controls ... -->
                <h2 class="text-xl font-semibold mb-4">3. 分割控制</h2>
                <div class="bg-gray-50 p-4 rounded-lg mb-4">
                    <h3 class="text-lg font-medium mb-3">自动分割</h3>
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <label for="silence-threshold" class="font-medium text-gray-700">静音阈值:</label>
                            <span id="threshold-value">{{ silenceThreshold }} dB</span>
                        </div>
                        <input type="range" id="silence-threshold" min="-60" max="-20" v-model.number="silenceThreshold" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer sensitivity-slider">
                    </div>
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <label for="min-silence-duration" class="font-medium text-gray-700">最小静音持续时间:</label>
                            <span id="min-silence-value">{{ minSilenceDuration }} 秒</span>
                        </div>
                        <input type="range" id="min-silence-duration" min="0.2" max="2" step="0.1" v-model.number="minSilenceDuration" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer sensitivity-slider">
                    </div>
                    <button id="auto-split" @click="autoSplitAudio" class="w-full py-2 px-4 bg-indigo-500 hover:bg-indigo-600 text-white font-semibold rounded-lg transition duration-200 flex items-center justify-center" :disabled="!isAudioLoaded">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1h1a1 1 0 010 2H6v1a1 1 0 01-2 0V6H3a1 1 0 010-2h1V3a1 1 0 011-1zm0 10a1 1 0 011 1v1h1a1 1 0 110 2H6v1a1 1 0 11-2 0v-1H3a1 1 0 110-2h1v-1a1 1 0 011-1zM12 2a1 1 0 01.967.744L14.146 7.2 17.5 9.134a1 1 0 010 1.732l-3.354 1.935-1.18 4.455a1 1 0 01-1.933 0L9.854 12.8 6.5 10.866a1 1 0 010-1.732l3.354-1.935 1.18-4.455A1 1 0 0112 2z" clip-rule="evenodd" /></svg>
                        自动检测分割点
                    </button>
                </div>
            </div>

            <!-- 4. Segments List & AI Summary -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6" v-show="isAudioLoaded">
                 <h2 class="text-xl font-semibold mb-4">4. 分割片段列表</h2>
                <!-- ... existing segments list table ... -->
                <div ref="segmentControlsContainer" :class="{ 'sticky-controls': isSegmentControlsSticky }">
                    <div id="segment-controls" class="mb-4">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center">
                                <input type="checkbox" id="select-all-segments" class="mr-2" v-model="selectAllSegments" @change="toggleSelectAll">
                                <label for="select-all-segments" class="text-gray-700">全选</label>
                            </div>
                            <div class="flex">
                                <button id="delete-selected-segments" @click="deleteSelectedSegments" :disabled="selectedSegmentIds.length === 0" class="py-1 px-3 bg-red-500 hover:bg-red-600 text-white font-medium rounded-lg transition duration-200 flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                    删除片段
                                </button>
                                <button id="merge-selected-segments" @click="mergeSelectedSegments" :disabled="selectedSegmentIds.length < 2" class="py-1 px-3 bg-blue-500 hover:bg-blue-600 text-white font-medium rounded-lg transition duration-200 flex items-center ml-2 disabled:opacity-50 disabled:cursor-not-allowed">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                                    合并片段
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mb-4 overflow-x-auto">
                    <table class="min-w-full bg-white">
                        <thead>
                            <tr class="bg-gray-100 text-gray-700">
                                <th class="py-2 px-4 border-b text-center w-16">选择</th>
                                <th class="py-2 px-4 border-b text-left w-16">序号</th>
                                <th class="py-2 px-4 border-b text-left">名称</th>
                                <th class="py-2 px-4 border-b text-left w-24">开始</th>
                                <th class="py-2 px-4 border-b text-left w-24">结束</th>
                                <th class="py-2 px-4 border-b text-left w-20">时长</th>
                                <th class="py-2 px-4 border-b text-center w-48">操作</th>
                            </tr>
                        </thead>
                        <tbody id="segments-table">
                            <tr v-if="segments.length === 0">
                                <td colspan="7" class="py-4 text-center text-gray-500">未检测到分割片段</td>
                            </tr>
                            <tr v-for="(segment, index) in segments" :key="segment.id" class="segment-row hover:bg-gray-50">
                                <td class="py-3 px-4 border-b text-center">
                                    <input type="checkbox" class="segment-checkbox" :value="segment.id" v-model="selectedSegmentIds">
                                </td>
                                <td class="py-3 px-4 border-b">{{ index + 1 }}</td>
                                <td class="py-3 px-4 border-b">
                                    <div class="flex items-center">
                                        <input type="text" v-model="segment.name" @change="validateSegmentName(segment)" class="segment-name-input w-full px-2 py-1 border rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-400 focus:border-blue-400">
                                    </div>
                                </td>
                                <td class="py-3 px-4 border-b">{{ formatTime(segment.start) }}</td>
                                <td class="py-3 px-4 border-b">{{ formatTime(segment.end) }}</td>
                                <td class="py-3 px-4 border-b">{{ segment.duration.toFixed(1) }}s</td>
                                <td class="py-3 px-4 border-b text-center">
                                    <div class="flex justify-center space-x-2">
                                        <button @click="previewSegment(segment.start, segment.end)" class="preview-segment bg-blue-100 hover:bg-blue-200 text-blue-700 px-2 py-1 rounded text-sm flex items-center" title="预览">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                                            预览
                                        </button>
                                        <button @click="exportSegment(segment)" class="export-segment bg-green-100 hover:bg-green-200 text-green-700 px-2 py-1 rounded text-sm flex items-center" title="导出">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                                            导出
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- 5. Batch Rename -->
                <h2 class="text-xl font-semibold mb-4 mt-6">5. 批量重命名 <span class="text-sm text-yellow-500">（检查格式）</span></h2>
                <!-- ... existing batch rename ... -->
                <div class="mb-4">
                    <textarea id="batch-rename-text" v-model="batchRenameText" class="w-full px-3 py-2 border rounded-lg text-gray-700 focus:outline-none focus:border-blue-500" rows="5" placeholder="请输入新的名称列表，每行一个名称，将按顺序应用到分割片段"></textarea>
                    <div class="mt-2 text-sm text-gray-500">提示：输入的行数应与分割片段数量相同，否则多余的行将被忽略，不足的片段将保持原名称。支持格式如 "Speaker01 Text Content" 或 "Speaker01 Text/Content" (后者会自动拆分为 Speaker01 Text_Content_0, Speaker01 Text_Content_1)。</div>
                    <div class="mt-3 flex justify-end">
                        <button id="apply-rename" @click="applyBatchRename" class="py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-lg transition duration-200 flex items-center" :disabled="segments.length === 0 || !batchRenameText.trim()">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                            批量重命名
                        </button>
                    </div>
                </div>

                <!-- Export All -->
                <div class="mt-6 flex justify-center">
                    <button id="export-all" @click="exportAllSegments" class="py-3 px-6 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-200 flex items-center" :disabled="!isAudioLoaded || segments.length === 0">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                        批量导出所有分割片段
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onBeforeUnmount, nextTick } = Vue;

        createApp({
            setup() {
                // --- Reactive State ---
                const wavesurferInstance = ref(null);
                const audioContext = ref(null);
                const audioBuffer = ref(null);
                const currentAudioFile = ref(null); // Store the actual File object
                const isPlaying = ref(false);
                const isLoading = ref(false);
                const loadingMessage = ref('处理中，请稍候...');
                const currentAudioFileURL = ref(null);
                const originalFileName = ref("");
                const fileInfo = ref("未选择文件");
                const isAudioLoaded = ref(false);
                const currentTime = ref(0);
                const totalTime = ref(0);
                const segments = ref([]);
                const segmentCounter = ref(0);
                const batchRenameText = ref("");
                const silenceThreshold = ref(-40);
                const minSilenceDuration = ref(0.5);
                const selectedSegmentIds = ref([]);
                const selectAllSegments = ref(false);
                const isDraggingOver = ref(false);
                const isSegmentControlsSticky = ref(false);
                const showJsonView = ref(false);

                const CONFIG = {
                    url: 'https://asnlee-gemini.hf.space/openai/v1/chat/completions', // e.g., 'https://api.openai.com/v1' or your HF space
                    key: '', // Bearer your_key or just key
                    sttModel: 'gemini-2.5-flash-preview-04-17',
                    summaryModel: 'gemini-2.5-flash-preview-04-17', // or gemini-pro, etc.
                }

                // --- New AI Feature State ---
                const apiConfig = reactive({ ...CONFIG });
                const apiSettingsVisible = ref(false);
                const subtitles = ref([]); // Array of { start, end, text }
                const isLoadingSubtitles = ref(false);
                const aiSummaryJson = ref('');
                const isLoadingSummary = ref(false);
                const fullTranscript = ref(''); // Store full transcript from STT

                // --- Refs for DOM Elements ---
                const waveform = ref(null);
                const timeline = ref(null);
                const audioInput = ref(null);
                const segmentControlsContainer = ref(null);

                // --- Computed Properties ---
                const formattedCurrentTime = computed(() => formatTime(currentTime.value));
                const formattedTotalTime = computed(() => formatTime(totalTime.value));
                const hasRegions = computed(() => wavesurferInstance.value && Object.keys(wavesurferInstance.value.regions.list).length > 0);

                // --- Methods ---

                const formatTime = (timeInSeconds) => {
                    if (isNaN(timeInSeconds) || timeInSeconds < 0) return "0:00";
                    const minutes = Math.floor(timeInSeconds / 60);
                    const seconds = Math.floor(timeInSeconds % 60);
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                };

                const showLoading = (message = "处理中，请稍候...") => {
                    loadingMessage.value = message;
                    isLoading.value = true;
                };
                const hideLoading = () => {
                    isLoading.value = false;
                };

                const initWaveSurfer = () => {
                    if (wavesurferInstance.value) {
                        wavesurferInstance.value.destroy();
                    }
                    wavesurferInstance.value = WaveSurfer.create({
                        container: waveform.value, // Use ref directly
                        waveColor: '#4A90E2',
                        progressColor: '#2574c4',
                        cursorColor: '#FF5500',
                        cursorWidth: 2,
                        barWidth: 2,
                        barGap: 1,
                        height: 128,
                        responsive: true,
                        normalize: true,
                        plugins: [
                            WaveSurfer.regions.create({ dragSelection: false }),
                            WaveSurfer.timeline.create({
                                container: timeline.value, // Use ref directly
                                primaryFontColor: '#3D3D3D',
                                secondaryFontColor: '#7D7D7D',
                                primaryColor: '#CCCCCC',
                                secondaryColor: '#DDDDDD'
                            })
                        ]
                    });

                    wavesurferInstance.value.on('ready', async () => {
                        totalTime.value = wavesurferInstance.value.getDuration();
                        isAudioLoaded.value = true;
                        isPlaying.value = false;
                        currentTime.value = 0;
                        clearAllMarkers(false);

                        try {
                            // Re-decode for offline context if needed, or use existing audioBuffer if already decoded
                            // For STT, we'll use the original file, so this part is mainly for export/auto-split
                            if (!audioBuffer.value && currentAudioFileURL.value) {
                                const response = await fetch(currentAudioFileURL.value);
                                const arrayBuffer = await response.arrayBuffer();
                                audioContext.value = new (window.AudioContext || window.webkitAudioContext)();
                                audioBuffer.value = await audioContext.value.decodeAudioData(arrayBuffer);
                            }
                            updateSegmentsList();
                            hideLoading();
                        } catch (error) {
                            console.error("Error decoding audio data:", error);
                            alert(`加载音频数据时出错: ${error.message}`);
                            hideLoading();
                            resetState();
                        }
                    });
                    wavesurferInstance.value.on('audioprocess', (time) => { currentTime.value = time; });
                    wavesurferInstance.value.on('seek', (progress) => { currentTime.value = progress * totalTime.value; });
                    wavesurferInstance.value.on('play', () => { isPlaying.value = true; });
                    wavesurferInstance.value.on('pause', () => { isPlaying.value = false; });
                    wavesurferInstance.value.on('finish', () => {
                        isPlaying.value = false;
                        wavesurferInstance.value.seekTo(0);
                        currentTime.value = 0;
                    });
                    wavesurferInstance.value.on('region-created', () => nextTick(updateSegmentsList));
                    wavesurferInstance.value.on('region-updated', () => nextTick(updateSegmentsList));
                    wavesurferInstance.value.on('region-removed', () => nextTick(updateSegmentsList));
                    wavesurferInstance.value.on('click', (progress, event) => {
                        if (event.target.closest('.wavesurfer-region, .region-handle')) return;
                        if (wavesurferInstance.value && isAudioLoaded.value && !isPlaying.value) {
                            addMarkerAtPosition(progress * totalTime.value);
                        }
                    });
                };

                const processFile = async (file) => {
                    if (!file.type.startsWith('audio/')) {
                        alert('请选择有效的音频文件');
                        return;
                    }
                    resetStateBeforeLoad();
                    currentAudioFile.value = file; // Store the File object
                    fileInfo.value = `已选择: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                    originalFileName.value = file.name.replace(/\.[^/.]+$/, "");

                    if (currentAudioFileURL.value) URL.revokeObjectURL(currentAudioFileURL.value);
                    currentAudioFileURL.value = URL.createObjectURL(file);

                    showLoading('正在加载音频文件...');
                    isAudioLoaded.value = false;

                    if (!wavesurferInstance.value) {
                        initWaveSurfer();
                    } else {
                        wavesurferInstance.value.empty();
                    }
                    
                    // Decode audio for offline processing (export, auto-split)
                    // This is separate from loading into wavesurfer for playback
                    try {
                        const arrayBuffer = await file.arrayBuffer(); // Read file as ArrayBuffer
                        audioContext.value = new (window.AudioContext || window.webkitAudioContext)();
                        audioBuffer.value = await audioContext.value.decodeAudioData(arrayBuffer.slice(0)); // Use a copy for decodeAudioData
                        wavesurferInstance.value.load(currentAudioFileURL.value); // Load for playback
                    } catch (error) {
                        console.error("Error processing audio file:", error);
                        alert(`处理音频文件时出错: ${error.message}`);
                        hideLoading();
                        resetState();
                    }
                };


                const handleFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) processFile(file);
                };
                const handleDragOver = (event) => { isDraggingOver.value = true; };
                const handleDragLeave = (event) => { isDraggingOver.value = false; };
                const handleDrop = (event) => {
                    isDraggingOver.value = false;
                    const file = event.dataTransfer.files[0];
                    if (file && file.type.startsWith('audio/')) {
                        processFile(file);
                        if (audioInput.value) audioInput.value.value = '';
                    } else {
                        alert('请拖放有效的音频文件');
                    }
                };

                const resetStateBeforeLoad = () => {
                    if (wavesurferInstance.value) wavesurferInstance.value.stop();
                    isPlaying.value = false;
                    isAudioLoaded.value = false;
                    // audioBuffer.value = null; // Keep audioBuffer if re-loading same file for STT later? No, new file means new buffer.
                    audioBuffer.value = null;
                    currentAudioFile.value = null;
                    segments.value = [];
                    segmentCounter.value = 0;
                    currentTime.value = 0;
                    totalTime.value = 0;
                    selectedSegmentIds.value = [];
                    selectAllSegments.value = false;
                    batchRenameText.value = "";
                    subtitles.value = []; // Clear subtitles
                    aiSummaryJson.value = ''; // Clear AI summary
                    fullTranscript.value = '';
                };
                const resetState = () => {
                    resetStateBeforeLoad();
                    fileInfo.value = "未选择文件";
                    originalFileName.value = "";
                    if (currentAudioFileURL.value) {
                        URL.revokeObjectURL(currentAudioFileURL.value);
                        currentAudioFileURL.value = null;
                    }
                    if (audioInput.value) audioInput.value.value = '';
                    if (wavesurferInstance.value) wavesurferInstance.value.empty();
                };

                const playPause = () => { if (wavesurferInstance.value && isAudioLoaded.value) wavesurferInstance.value.playPause(); };
                const zoomIn = () => { if (wavesurferInstance.value) wavesurferInstance.value.zoom(wavesurferInstance.value.params.minPxPerSec * 1.2); };
                const zoomOut = () => { if (wavesurferInstance.value) wavesurferInstance.value.zoom(Math.max(wavesurferInstance.value.params.minPxPerSec / 1.2, 20)); };

                const addMarkerAtCurrentTime = () => { if (wavesurferInstance.value && isAudioLoaded.value) addMarkerAtPosition(wavesurferInstance.value.getCurrentTime()); };
                const addMarkerAtPosition = (position) => {
                    if (!wavesurferInstance.value || position < 0 || position > totalTime.value) return;
                    const existingRegions = Object.values(wavesurferInstance.value.regions.list);
                    if (existingRegions.some(r => Math.abs(r.start - position) < 0.05)) return;
                    wavesurferInstance.value.addRegion({
                        id: 'marker-' + Date.now() + '-' + Math.random().toString(36).slice(2, 7),
                        start: position, end: position, color: 'rgba(255, 0, 0, 0.5)', drag: true, resize: false
                    });
                };
                const clearAllMarkers = (confirmUser = true) => {
                    if (!wavesurferInstance.value) return;
                    if (confirmUser && !confirm("确定要清除所有分割点吗？")) return;
                    wavesurferInstance.value.clearRegions();
                    segmentCounter.value = 0;
                    nextTick(updateSegmentsList);
                };

                const updateSegmentsList = () => {
                    // ... (Existing updateSegmentsList logic - no changes needed here for new features)
                    if (!wavesurferInstance.value || !isAudioLoaded.value) {
                        segments.value = [];
                        return;
                    }

                    const wsRegions = Object.values(wavesurferInstance.value.regions.list);
                    wsRegions.sort((a, b) => a.start - b.start);

                    const newSegments = [];
                    let lastEnd = 0;
                    let segmentIndex = 0; 

                    if (wsRegions.length === 0 || wsRegions[0].start > 0.01) { 
                         const end = wsRegions.length > 0 ? wsRegions[0].start : totalTime.value;
                         if (end - lastEnd >= 0.05) { 
                            segmentIndex++;
                            const segmentId = `segment-${segmentIndex}`;
                            const existing = segments.value.find(s => s.start.toFixed(3) === lastEnd.toFixed(3) && s.end.toFixed(3) === end.toFixed(3));
                            newSegments.push({
                                id: segmentId,
                                name: existing?.name || `片段 ${segmentIndex}`,
                                start: lastEnd,
                                end: end,
                                duration: end - lastEnd,
                                regionId: null 
                            });
                            lastEnd = end;
                        }
                    } else if (wsRegions.length > 0) {
                         lastEnd = wsRegions[0].start; 
                    }

                    for (let i = 0; i < wsRegions.length; i++) {
                        const region = wsRegions[i];
                        const start = lastEnd; 
                        const end = (i + 1 < wsRegions.length) ? wsRegions[i+1].start : totalTime.value;

                        if (end - start >= 0.05) { 
                            segmentIndex++;
                            const segmentId = `segment-${segmentIndex}`;
                            const existing = segments.value.find(s => s.start.toFixed(3) === start.toFixed(3) && s.end.toFixed(3) === end.toFixed(3));
                            newSegments.push({
                                id: segmentId,
                                name: existing?.name || `片段 ${segmentIndex}`,
                                start: start,
                                end: end,
                                duration: end - start,
                                regionId: region.id 
                            });
                        }
                         lastEnd = end; 
                         if (i + 1 < wsRegions.length) {
                             lastEnd = wsRegions[i+1].start;
                         }
                    }
                    const uniqueIds = new Set();
                    newSegments.forEach((seg, idx) => {
                        let finalId = seg.id;
                        let suffix = 0;
                        while (uniqueIds.has(finalId)) {
                            suffix++;
                            finalId = `segment-${idx + 1}-${suffix}`;
                        }
                        uniqueIds.add(finalId);
                        seg.id = finalId;
                    });
                    segments.value = newSegments;
                    selectedSegmentIds.value = [];
                    selectAllSegments.value = false;
                };

                const previewSegment = (start, end) => { if (!wavesurferInstance.value) return; wavesurferInstance.value.play(start, end); };
                const exportSegment = async (segment) => {
                    if (!audioBuffer.value) {
                        alert('音频数据尚未准备好，请稍后再试');
                        return;
                    }
                    showLoading(`正在导出: ${segment.name}...`);
                    await nextTick(); // Allow UI update

                    try {
                        const start = segment.start;
                        const end = segment.end;
                        const name = segment.name || `片段_${segment.id}`;

                        // Calculation and buffer creation
                        const sampleRate = audioBuffer.value.sampleRate;
                        const startSample = Math.floor(start * sampleRate);
                        const endSample = Math.floor(end * sampleRate);
                        // Ensure frameCount is at least 1 to avoid errors with zero-length buffers
                        const frameCount = Math.max(1, endSample - startSample);

                        // Use the *offline* context for potentially better performance/accuracy
                        const offlineCtx = new OfflineAudioContext(
                            audioBuffer.value.numberOfChannels,
                            frameCount,
                            sampleRate
                        );
                        const newSource = offlineCtx.createBufferSource();
                        newSource.buffer = audioBuffer.value;

                        // Connect source and start rendering
                        newSource.connect(offlineCtx.destination);
                        // Start playing the *segment* of the original buffer
                        newSource.start(0, start, end - start);

                        const renderedBuffer = await offlineCtx.startRendering();

                        // Convert to MP3
                        const mp3Blob = bufferToMp3(renderedBuffer); // Assuming bufferToMp3 exists globally or is defined here
                        const safeName = name.replace(/[\/\\?%*:|"<>]/g, '_'); // Sanitize filename
                        const fileName = `${safeName}.mp3`;

                        saveAs(mp3Blob, fileName); // Assuming saveAs exists globally

                    } catch (error) {
                        console.error('导出片段时出错:', error);
                        alert(`导出片段 "${segment.name}" 时出错: ${error.message}`);
                    } finally {
                        hideLoading();
                    }
                };

                const exportAllSegments = async () => {
                    if (!audioBuffer.value || segments.value.length === 0) {
                        alert('没有可导出的音频片段');
                        return;
                    }

                    showLoading(`准备导出 ${segments.value.length} 个片段... (0%)`);
                    await nextTick();

                    try {
                        const zip = new JSZip(); // Assuming JSZip is global
                        const totalCount = segments.value.length;

                        for (let i = 0; i < totalCount; i++) {
                            const segment = segments.value[i];
                            const progress = Math.round(((i + 1) / totalCount) * 100);
                            loadingMessage.value = `正在处理: ${segment.name} (${i + 1}/${totalCount}) - ${progress}%`;
                            await nextTick(); // Update message

                            // --- Extract segment buffer (similar to single export) ---
                            const start = segment.start;
                            const end = segment.end;
                            const name = segment.name || `片段_${segment.id}`;
                            const sampleRate = audioBuffer.value.sampleRate;
                            const startSample = Math.floor(start * sampleRate);
                            const endSample = Math.floor(end * sampleRate);
                            const frameCount = Math.max(1, endSample - startSample);

                            const offlineCtx = new OfflineAudioContext(audioBuffer.value.numberOfChannels, frameCount, sampleRate);
                            const newSource = offlineCtx.createBufferSource();
                            newSource.buffer = audioBuffer.value;
                            newSource.connect(offlineCtx.destination);
                            newSource.start(0, start, end - start);
                            const renderedBuffer = await offlineCtx.startRendering();
                            // --- End Extract ---

                            const mp3Blob = bufferToMp3(renderedBuffer);
                            const safeName = name.replace(/[\/\\?%*:|"<>]/g, '_');
                            const fileName = `${safeName}.mp3`;
                            zip.file(fileName, mp3Blob);
                        }

                        loadingMessage.value = '正在生成ZIP文件...';
                        await nextTick();

                        const zipBlob = await zip.generateAsync({ type: 'blob' });
                        const zipFileName = `${originalFileName.value || '音频片段'}_分割.zip`;
                        saveAs(zipBlob, zipFileName); // Assuming saveAs is global

                        hideLoading();
                        alert('所有片段已成功导出为ZIP文件');
                    } catch (error) {
                        console.error('批量导出片段时出错:', error);
                        alert(`批量导出片段时出错: ${error.message}`);
                        hideLoading(); // Ensure loading is hidden on error
                    }
                };

                 // MP3 Encoding (using lamejs - make sure it's loaded)
                const bufferToMp3 = (buffer, bitrate = 128) => {
                    if (typeof lamejs === 'undefined') {
                        console.error("lamejs library not loaded!");
                        throw new Error("MP3 编码库未加载");
                    }
                    const channels = buffer.numberOfChannels;
                    const sampleRate = buffer.sampleRate;
                    const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
                    const mp3Data = [];
                    const sampleBlockSize = 1152; // MP3 frame size

                    const processChannel = (channelData) => {
                        const samples = channelData;
                        const samplesInt16 = new Int16Array(samples.length);
                        for (let i = 0; i < samples.length; i++) {
                            // Clamp values to avoid issues with potential out-of-range floats
                            const s = Math.max(-1, Math.min(1, samples[i]));
                            samplesInt16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }
                        return samplesInt16;
                    };

                    if (channels === 1) {
                        const samplesInt16 = processChannel(buffer.getChannelData(0));
                        for (let i = 0; i < samplesInt16.length; i += sampleBlockSize) {
                            const sampleChunk = samplesInt16.subarray(i, i + sampleBlockSize);
                            const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
                            if (mp3buf.length > 0) mp3Data.push(mp3buf);
                        }
                    } else { // Stereo
                        const left = processChannel(buffer.getChannelData(0));
                        const right = processChannel(buffer.getChannelData(1));
                        for (let i = 0; i < left.length; i += sampleBlockSize) {
                            const leftChunk = left.subarray(i, i + sampleBlockSize);
                            const rightChunk = right.subarray(i, i + sampleBlockSize);
                            const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                            if (mp3buf.length > 0) mp3Data.push(mp3buf);
                        }
                    }

                    const endMp3buf = mp3encoder.flush();
                    if (endMp3buf.length > 0) mp3Data.push(endMp3buf);

                    // Combine chunks into a single Uint8Array
                    const totalLength = mp3Data.reduce((acc, buf) => acc + buf.length, 0);
                    const mp3Array = new Uint8Array(totalLength);
                    let offset = 0;
                    mp3Data.forEach(buf => {
                        mp3Array.set(buf, offset);
                        offset += buf.length;
                    });

                    return new Blob([mp3Array], { type: 'audio/mp3' });
                };


                // Batch Rename
                const applyBatchRename = () => {
                    const lines = batchRenameText.value.trim().split('\n');
                    if (lines.length === 0 || (lines.length === 1 && !lines[0])) {
                        alert('请输入至少一个名称');
                        return;
                    }

                    const newNames = lines.flatMap(line => {
                        const trimmedLine = line.trim();
                        if (!trimmedLine) return []; // Skip empty lines

                        // Handle "Speaker Text/More Text" format -> Speaker Text_More Text_0, Speaker Text_More Text_1
                        if (trimmedLine.includes('/') && trimmedLine.split(' ').length > 1) {
                             const parts = trimmedLine.split(' ');
                             const speaker = parts[0];
                             const rest = parts.slice(1).join(' ');
                             if (rest.includes('/')) {
                                 const subParts = rest.split('/');
                                 return subParts.map((sub, i) => `${speaker} ${sub.trim()}_${i}`);
                             }
                        }
                        // Handle simple case or lines without '/' after the first word
                        return trimmedLine;
                    });


                    let appliedCount = 0;
                    segments.value.forEach((segment, index) => {
                        if (index < newNames.length && newNames[index]) {
                            segment.name = newNames[index];
                            appliedCount++;
                        }
                    });

                    alert(`已应用 ${appliedCount} 个名称`);
                };

                // Auto Split
                const autoSplitAudio = async () => {
                    if (!audioBuffer.value) {
                        alert('音频数据尚未准备好，请稍后再试');
                        return;
                    }

                    if (hasRegions.value && !confirm("将清除现有分割点并自动检测，是否继续？")) {
                        return;
                    }

                    clearAllMarkers(false); // Clear existing markers without confirmation
                    showLoading('正在分析音频特征...');
                    await nextTick(); // Allow UI update

                    try {
                        // Use a Promise to allow async processing without blocking UI thread for too long
                        await new Promise(resolve => setTimeout(resolve, 50)); // Short delay

                        const thresholdLinear = Math.pow(10, silenceThreshold.value / 20);
                        const sampleRate = audioBuffer.value.sampleRate;
                        const minSilenceSamples = Math.floor(minSilenceDuration.value * sampleRate);
                        const channelData = audioBuffer.value.getChannelData(0); // Analyze first channel
                        const bufferLength = channelData.length;

                        let inSilence = false;
                        let silenceStartSample = 0;
                        const splitPoints = []; // Store split times in seconds

                        // More efficient analysis (e.g., analyze blocks)
                        const analysisBlockSize = Math.floor(sampleRate * 0.05); // Analyze 50ms blocks
                        let blockMaxAmplitude = 0;

                        for (let i = 0; i < bufferLength; i++) {
                            // Simple absolute value check within block
                            blockMaxAmplitude = Math.max(blockMaxAmplitude, Math.abs(channelData[i]));

                            if ((i + 1) % analysisBlockSize === 0 || i === bufferLength - 1) {
                                // End of block or end of audio
                                const isBlockSilent = blockMaxAmplitude < thresholdLinear;
                                const currentBlockEndSample = i;
                                const currentBlockStartSample = Math.max(0, i - analysisBlockSize + 1);

                                if (isBlockSilent) {
                                    if (!inSilence) {
                                        inSilence = true;
                                        // Mark silence start roughly at the beginning of this silent block
                                        silenceStartSample = currentBlockStartSample;
                                    }
                                } else { // Block has sound
                                    if (inSilence) {
                                        // End of a silence period
                                        const silenceEndSample = currentBlockStartSample; // End silence before this block
                                        const silenceDurationSamples = silenceEndSample - silenceStartSample;

                                        if (silenceDurationSamples >= minSilenceSamples) {
                                            // Add split point in the middle of the silence
                                            const splitSample = silenceStartSample + Math.floor(silenceDurationSamples / 2);
                                            splitPoints.push(splitSample / sampleRate);
                                        }
                                    }
                                    inSilence = false;
                                }
                                blockMaxAmplitude = 0; // Reset for next block
                            }
                        }

                        // Add markers based on detected split points
                        splitPoints.forEach(time => addMarkerAtPosition(time));

                        loadingMessage.value = `自动检测完成，添加了 ${splitPoints.length} 个分割点`;
                        await new Promise(resolve => setTimeout(resolve, 1500)); // Show message briefly

                    } catch (error) {
                        console.error('自动分割时出错:', error);
                        alert(`自动分割时出错: ${error.message}`);
                    } finally {
                        hideLoading();
                        // updateSegmentsList will be triggered by addMarkerAtPosition -> region-created
                    }
                };

                // Split by subtitles
                const splitBySubtitles = () => {
                    if (!subtitles.value || subtitles.value.length === 0) {
                        alert("没有可用的字幕数据，请先生成字幕");
                        return;
                    }
                    
                    if (hasRegions.value && !confirm("将清除现有分割点并按字幕创建新分割点，是否继续？")) {
                        return;
                    }
                    
                    clearAllMarkers(false); // Clear existing markers without confirmation
                    
                    // Add markers at the start of each subtitle
                    subtitles.value.forEach(subtitle => {
                        addMarkerAtPosition(subtitle.start);
                    });
                    
                    // Optionally add a marker at the end of the last subtitle
                    if (subtitles.value.length > 0) {
                        const lastSubtitle = subtitles.value[subtitles.value.length - 1];
                        if (lastSubtitle.end < wavesurferInstance.value.getDuration()) {
                            addMarkerAtPosition(lastSubtitle.end);
                        }
                    }
                };
                
                // Split by chapters from AI summary
                const splitByChapters = () => {
                    if (!aiSummaryJson.value || !aiSummaryJson.value.chapters || aiSummaryJson.value.chapters.length === 0) {
                        alert("没有可用的章节数据，请先生成AI摘要");
                        return;
                    }
                    
                    if (hasRegions.value && !confirm("将清除现有分割点并按章节创建新分割点，是否继续？")) {
                        return;
                    }
                    
                    clearAllMarkers(false); // Clear existing markers without confirmation
                    
                    // Add markers at the start of each chapter
                    aiSummaryJson.value.chapters.forEach(chapter => {
                        addMarkerAtPosition(chapter.start);
                    });
                    
                    // Optionally add a marker at the end of the last chapter
                    if (aiSummaryJson.value.chapters.length > 0) {
                        const lastChapter = aiSummaryJson.value.chapters[aiSummaryJson.value.chapters.length - 1];
                        if (lastChapter.end < wavesurferInstance.value.getDuration()) {
                            addMarkerAtPosition(lastChapter.end);
                        }
                    }
                };
                
                // Segment Selection & Operations
                const toggleSelectAll = () => {
                    if (selectAllSegments.value) {
                        selectedSegmentIds.value = segments.value.map(s => s.id);
                    } else {
                        selectedSegmentIds.value = [];
                    }
                };

                const deleteSelectedSegments = () => {
                    if (selectedSegmentIds.value.length === 0) return;
                    if (!confirm(`确定要删除选中的 ${selectedSegmentIds.value.length} 个片段吗？\n这将移除相应的分割点。`)) {
                        return;
                    }

                    const regionsToRemove = new Set();
                    const selectedSegmentsData = segments.value.filter(s => selectedSegmentIds.value.includes(s.id));

                    // 修复：正确识别需要删除的分割点
                    selectedSegmentsData.forEach(segment => {
                        // 查找与当前片段结束位置匹配的区域（分割点）
                        const endRegion = Object.values(wavesurferInstance.value.regions.list)
                                           .find(r => Math.abs(r.start - segment.end) < 0.01);
                        if (endRegion) {
                            regionsToRemove.add(endRegion.id);
                        }
                    });

                    regionsToRemove.forEach(regionId => {
                        wavesurferInstance.value.regions.list[regionId]?.remove();
                    });

                    // Clear selection after deletion
                    selectedSegmentIds.value = [];
                    selectAllSegments.value = false;
                    // updateSegmentsList will be triggered by region-removed
                    nextTick(() => {
                        updateSegmentsList();
                    });
                };

                const mergeSelectedSegments = () => {
                    if (selectedSegmentIds.value.length < 2) {
                        alert('请至少选择两个连续的片段进行合并');
                        return;
                    }

                    // Get selected segment data and sort by start time
                    const segmentsToMerge = segments.value
                        .filter(s => selectedSegmentIds.value.includes(s.id))
                        .sort((a, b) => a.start - b.start);

                    // Check for continuity
                    let isConsecutive = true;
                    for (let i = 0; i < segmentsToMerge.length - 1; i++) {
                        // Allow for small floating point differences
                        if (Math.abs(segmentsToMerge[i].end - segmentsToMerge[i+1].start) > 0.01) {
                            isConsecutive = false;
                            break;
                        }
                    }

                    if (!isConsecutive) {
                        alert('选中的片段必须是连续的才能合并');
                        return;
                    }

                    if (!confirm(`确定要合并选中的 ${segmentsToMerge.length} 个连续片段吗？\n这将移除它们之间的分割点。`)) {
                        return;
                    }

                    // Identify regions (markers) between the selected segments to remove
                    const regionsToRemove = new Set();
                    for (let i = 0; i < segmentsToMerge.length - 1; i++) {
                        const segmentEnd = segmentsToMerge[i].end;
                        // Find the region marker at this end time
                         const region = Object.values(wavesurferInstance.value.regions.list)
                                           .find(r => Math.abs(r.start - segmentEnd) < 0.01);
                        if (region) {
                            regionsToRemove.add(region.id);
                        }
                    }

                    regionsToRemove.forEach(regionId => {
                         wavesurferInstance.value.regions.list[regionId]?.remove();
                    });

                    // Clear selection after merge
                    selectedSegmentIds.value = [];
                    selectAllSegments.value = false;
                     // updateSegmentsList will be triggered by region-removed
                };

                 // Validate segment name (e.g., on input change)
                const validateSegmentName = (segment) => {
                    // Basic validation: ensure name is not empty after trimming
                    if (!segment.name.trim()) {
                        // Find index to generate default name
                        const index = segments.value.findIndex(s => s.id === segment.id);
                        segment.name = `片段 ${index + 1}`;
                        alert("片段名称不能为空。已重置为默认名称。");
                    }
                    // Could add more validation here (e.g., forbidden characters for filenames)
                };

                // Sticky Header Logic
                const handleScroll = () => {
                    if (!segmentControlsContainer.value) return;
                    const containerTop = segmentControlsContainer.value.getBoundingClientRect().top;
                    // Stick when the container's top edge reaches the viewport top (or slightly below)
                    isSegmentControlsSticky.value = containerTop <= 10; // Adjust offset as needed
                };

                // --- Lifecycle Hooks ---
                onMounted(() => {
                    // Don't init WaveSurfer immediately, wait for file upload.
                    // initWaveSurfer(); // Moved initialization to file processing
                    window.addEventListener('scroll', handleScroll);
                });

                onBeforeUnmount(() => {
                    if (wavesurferInstance.value) {
                        wavesurferInstance.value.destroy();
                    }
                    if (currentAudioFileURL.value) {
                        URL.revokeObjectURL(currentAudioFileURL.value); // Clean up object URL
                    }
                    if (audioContext.value && audioContext.value.state !== 'closed') {
                        audioContext.value.close(); // Close audio context
                    }
                     window.removeEventListener('scroll', handleScroll);
                });


                // --- NEW: API Settings ---
                const toggleApiSettings = () => {
                    apiSettingsVisible.value = !apiSettingsVisible.value;
                };

                const loadApiConfig = () => {
                    const savedConfig = localStorage.getItem('audioEditorApiConfig');
                    if (savedConfig) {
                        try {
                            const parsed = JSON.parse(savedConfig);
                            Object.assign(apiConfig, parsed);
                        } catch (e) {
                            console.error("Error parsing saved API config:", e);
                            // Use defaults if parsing fails
                            Object.assign(apiConfig, CONFIG);
                        }
                    }
                };

                const saveApiConfig = () => {
                    localStorage.setItem('audioEditorApiConfig', JSON.stringify(apiConfig));
                    alert('API 设置已保存！');
                };

                // --- NEW: Subtitle Generation (STT) ---
                const generateSubtitles = async () => {
                    if (!currentAudioFile.value) {
                        alert('请先上传音频文件');
                        return;
                    }
                    if (!apiConfig.url || !apiConfig.key || !apiConfig.summaryModel) {
                        alert('请先配置 API URL, Key 和模型');
                        return;
                    }

                    isLoadingSubtitles.value = true;
                    subtitles.value = [];
                    fullTranscript.value = '';
                    showLoading('正在生成字幕...');

                    try {
                        // 将音频转换为Base64
                        const audioBase64 = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.readAsDataURL(currentAudioFile.value);
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = error => reject(error);
                        });

                        // 创建提示词
                        const prompt = `
You're a professional audio transcription expert. I'll provide a Base64-encoded audio file. Analyze it carefully and transcribe it into text, marking the start and end time of each sentence.

The JSON array MUST include the following keys:
- "start": Start time (seconds)
- "end":End time (seconds)
- "text": audio text

The audio is approximately ${totalTime.value} seconds long. Ensure:
1. Timestamps accurately reflect sentence positions
2. Segments cover the entire audio (0 to end)
3. No overlapping between adjacent segments
4. Text matches the audio content

Ensure the output is ONLY a valid JSON object, starting with { and ending with }. Do not include any explanatory text before or after the JSON.
`;

                        const messages = [
                            {
                                role: "user",
                                content: [
                                    { type: "text", text: prompt },
                                    {
                                        type: "image_url",
                                        image_url: { url: audioBase64 }
                                    }
                                ]
                            },
                        ];
                        
                        const requestBody = JSON.stringify({
                            model: apiConfig.sttModel,
                            messages: messages,
                            temperature: 0.3,
                            stream: false,
                            response_format: { type: "json_object" }
                        });

                        const response = await fetch(apiConfig.url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiConfig.key}` ,
                            },
                            body: requestBody
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                            throw new Error(`API Error (${response.status}): ${errorData.error?.message || 'Unknown error'}`);
                        }

                        const data = await response.json();
                        let resultText = '';
                        
                        if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                            resultText = data.choices[0].message.content;
                            resultText = resultText.replace(/^```json\s*|```$/g, '').trim()
                        } else {
                            throw new Error('API未返回预期格式的响应。');
                        }
                        
                        // 解析JSON响应
                        try {
                            const parsedResult = JSON.parse(resultText);
                            
                            if (Array.isArray(parsedResult)) {
                                subtitles.value = parsedResult.map(seg => ({
                                    start: seg.start,
                                    end: seg.end,
                                    text: seg.text.trim()
                                }));
                                fullTranscript.value = resultText;
                            } else {
                                throw new Error('API返回的JSON格式不符合预期（缺少text或segments）。');
                            }
                            
                            if (subtitles.value.length === 0 && !fullTranscript.value) {
                                alert('未能从音频中识别出文本。');
                            }
                        } catch (parseError) {
                            console.error('解析JSON响应失败:', parseError, '原始响应:', resultText);
                            throw new Error('解析API响应失败: ' + parseError.message);
                        }

                    } catch (error) {
                        console.error('生成字幕时出错:', error);
                        alert(`生成字幕失败: ${error.message}`);
                        subtitles.value = [];
                        fullTranscript.value = '';
                    } finally {
                        isLoadingSubtitles.value = false;
                        hideLoading();
                    }
                };

                const seekToSubtitle = (time) => {
                    if (wavesurferInstance.value) {
                        wavesurferInstance.value.seekTo(time / totalTime.value);
                        wavesurferInstance.value.play(); // Optionally auto-play
                    }
                };

                // --- NEW: AI Summary ---
                const generateAiSummary = async () => {
                    if (fullTranscript.value.trim() === '') {
                        alert('请先生成字幕，AI 摘要将基于字幕内容。');
                        return;
                    }
                    if (!apiConfig.url || !apiConfig.key || !apiConfig.summaryModel) {
                        alert('请先配置 API URL, Key 和摘要模型');
                        return;
                    }

                    isLoadingSummary.value = true;
                    aiSummaryJson.value = '';
                    showLoading('正在生成 AI 摘要...');

                    const prompt = `
You are an expert podcast producer. Given the following transcript, generate a JSON summary in a podcast format.

The JSON object MUST include the following keys:
- "podcastTitle": A suitable title for a podcast series this audio might belong to (e.g., "Audio Insights", "Tech Talks Daily").
- "episodeTitle": A concise and engaging title for this specific audio segment/episode.
- "overallSummary": A 2-4 sentence overview of the entire content.
- "chapters": An array of objects. Each object should represent a key section or topic discussed and MUST have "start" (Start time (seconds)) and "end" (End time (seconds)) and "title" (string, a short, descriptive title for the chapter). Identify 3-5 key chapters. If the transcript is short, 1-2 chapters are fine.
- "keyTakeaways": An array of strings. List 3-5 main points, actionable insights, or memorable quotes from the transcript.
- "tags": An array of 3-7 relevant keywords or tags for this content.

Ensure the output is ONLY a valid JSON object, starting with { and ending with }. Do not include any explanatory text before or after the JSON.

Transcript:
"""
${fullTranscript.value}
"""
                    `;

                    try {
                        const messages = [{"role": "user", "content": prompt}];
                        const requestBody = JSON.stringify({
                            model: apiConfig.summaryModel,
                            messages: messages,
                            temperature: 0.5, // Adjust as needed
                            response_format: { type: "json_object" } // For newer OpenAI models
                        });

                        const response = await fetch(apiConfig.url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiConfig.key}` ,
                            },
                            body: requestBody,
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                            throw new Error(`API Error (${response.status}): ${errorData.error?.message || 'Unknown error'}`);
                        }

                        const data = await response.json();
                        let summaryText;

                        if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) { // OpenAI like
                            summaryText = data.choices[0].message.content;
                            summaryText = summaryText.replace(/^```json\s*|```\s*$/g, '').trim();
                        } else {
                            throw new Error('Summary API did not return expected format.');
                        }
                        
                        // Try to parse the summaryText as JSON
                        try {
                            const cleanedJsonString = JSON.parse(summaryText);
                            aiSummaryJson.value = cleanedJsonString; // Store the cleaned, valid JSON string
                        } catch (parseError) {
                            console.error("Failed to parse AI summary as JSON:", parseError, "Raw response:", summaryText);
                            aiSummaryJson.value = `Error: AI response was not valid JSON.\nRaw response:\n${summaryText}`;
                        }

                    } catch (error) {
                        console.error('Error generating AI summary:', error);
                        alert(`生成 AI 摘要失败: ${error.message}`);
                        aiSummaryJson.value = `Error: ${error.message}`;
                    } finally {
                        isLoadingSummary.value = false;
                        hideLoading();
                    }
                };

                const copySummaryToClipboard = () => {
                    if (aiSummaryJson.value) {
                        navigator.clipboard.writeText(aiSummaryJson.value)
                            .then(() => alert('AI 摘要已复制到剪贴板!'))
                            .catch(err => alert('复制失败: ' + err));
                    }
                };


                // --- Lifecycle Hooks ---
                onMounted(() => {
                    loadApiConfig(); // Load saved API settings
                    // initWaveSurfer(); // Moved to processFile
                    window.addEventListener('scroll', handleScroll);
                });

                onBeforeUnmount(() => {
                    if (wavesurferInstance.value) wavesurferInstance.value.destroy();
                    if (currentAudioFileURL.value) URL.revokeObjectURL(currentAudioFileURL.value);
                    if (audioContext.value && audioContext.value.state !== 'closed') audioContext.value.close();
                    window.removeEventListener('scroll', handleScroll);
                });

                return {
                    // Existing state and methods
                    isPlaying, isLoading, loadingMessage, fileInfo, isAudioLoaded, currentTime, totalTime,
                    segments, batchRenameText, silenceThreshold, minSilenceDuration, selectedSegmentIds,
                    selectAllSegments, isDraggingOver, isSegmentControlsSticky,
                    formattedCurrentTime, formattedTotalTime, hasRegions, showJsonView,
                    handleFileUpload, handleDragOver, handleDragLeave, handleDrop, playPause, zoomIn, zoomOut,
                    addMarkerAtCurrentTime, clearAllMarkers, previewSegment, exportSegment, exportAllSegments,
                    applyBatchRename, autoSplitAudio, splitByChapters, splitBySubtitles, toggleSelectAll, deleteSelectedSegments, mergeSelectedSegments,
                    formatTime, validateSegmentName,
                    waveform, timeline, audioInput, segmentControlsContainer,

                    // New AI features state and methods
                    apiConfig,
                    apiSettingsVisible,
                    toggleApiSettings,
                    saveApiConfig,
                    subtitles,
                    isLoadingSubtitles,
                    generateSubtitles,
                    seekToSubtitle,
                    aiSummaryJson,
                    isLoadingSummary,
                    generateAiSummary,
                    copySummaryToClipboard,
                };
            }

        }).mount('#app');
    </script>

    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@6.6.4/dist/wavesurfer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@6.6.4/dist/plugin/wavesurfer.regions.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@6.6.4/dist/plugin/wavesurfer.timeline.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
</body>
</html>